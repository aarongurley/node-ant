{
  "name": "usb",
  "description": "Library to access USB devices",
  "keywords": [
    "usb",
    "hardware"
  ],
  "author": {
    "name": "Nonolith Labs",
    "url": "http://www.nonolithlabs.com"
  },
  "contributors": [
    {
      "name": "Kevin Mehall",
      "email": "km@kevinmehall.net",
      "url": "http://kevinmehall.net"
    },
    {
      "name": "Christopher Klein"
    }
  ],
  "version": "0.2.3",
  "engines": {
    "node": ">=0.8.x"
  },
  "main": "./usb",
  "repository": {
    "type": "git",
    "url": "https://github.com/nonolith/node-usb.git"
  },
  "scripts": {
    "preinstall": "node-gyp rebuild",
    "test": "mocha --compilers coffee:coffee-script",
    "valgrind": "valgrind --leak-check=full --show-possibly-lost=no node --expose-gc --trace-gc node_modules/mocha/bin/_mocha -R spec --compilers coffee:coffee-script"
  },
  "dependencies": {
    "bindings": "1.0.x"
  },
  "devDependencies": {
    "coffee-script": "~1.6.2",
    "mocha": "~1.8.2"
  },
  "license": "MIT",
  "readme": "USB Library for Node.JS\n===============================\n\nNode.JS library for communicating with USB devices in JavaScript / CoffeeScript.\n\nThis is a refactoring / rewrite of Christopher Klein's [node-usb](https://github.com/schakko/node-usb). The API is not compatible (hopefully you find it an improvement).\n\nIt's based entirely on libusb's asynchronous API for better efficiency, and provides a stream API for continuously streaming data or events.\n\nTested with Node 0.10/Fedora and Node 0.10/WinXP.\n\nInstallation\n============\n\nLibusb is required. Older versions of libusb segfault when using bulk or interrupt endpoints.\nUse [libusb](http://libusb.org) or [libusbx](http://libusbx.org) 1.0.9 or greater.\n\n**Ubuntu/Debian:** `sudo apt-get install build-essential pkg-config libusb-1.0-0-dev`  \n**Fedora:** `sudo yum install libusbx-devel`\n\n**OSX:** `brew install libusb pkg-config`\n\n**Windows:** Download a Windows Binary package from http://libusbx.org/ and extract it at `C:\\Program Files\\libusb`. Use [Zadig](http://sourceforge.net/projects/libwdi/files/zadig/) to install the WinUSB driver for your USB device. Otherwise you will get a `LIBUSB_ERROR_NOT_SUPPORTED` when attempting to open devices.\n\nThen, just run\n\n\tnpm install usb\n\nto install from npm. See the bottom of this page for instructions for building from a git checkout.\n\nAPI\n===\n\n  var usb = require('usb')\n\nusb\n---\n\nTop-level object.\n\n### usb.getDeviceList()\nReturn a list of `Device` objects for the USB devices attached to the system.\n\n### usb.findByIds(vid, pid)\nConvenience method to get the first device with the specified VID and PID, or `undefined` if no such device is present.\n\n### usb.LIBUSB_*\nConstant properties from libusb\n\n### usb.setDebugLevel(level : int)\nSet the libusb debug level (between 0 and 4)\n\nDevice\n------\n\nRepresents a USB device.\n\n### .busNumber\nInteger USB device number\n\n### .deviceAddress\nInteger USB device address\n\n### .deviceDescriptor\nObject with properties for the fields of the device descriptor:\n\n  - bLength\n  - bDescriptorType\n  - bcdUSB\n  - bDeviceClass\n  - bDeviceSubClass\n  - bDeviceProtocol\n  - bMaxPacketSize0\n  - idVendor\n  - idProduct\n  - bcdDevice\n  - iManufacturer\n  - iProduct\n  - iSerialNumber\n  - bNumConfigurations\n\n### .configDescriptor\nObject with properties for the fields of the configuration descriptor:\n\n  - bLength\n  - bDescriptorType\n  - wTotalLength\n  - bNumInterfaces\n  - bConfigurationValue\n  - iConfiguration\n  - bmAttributes\n  - MaxPower\n\n### .open()\n\nOpen the device. All methods below require the device to be open before use.\n\n### .close()\n\nClose the device.\n\n### .controlTransfer(bmRequestType, bRequest, wValue, wIndex, data_or_length, callback(error, data))\n\nPerform a control transfer with `libusb_control_transfer`.\n\nParameter `data_or_length` can be a integer length for an IN transfer, or a Buffer for an out transfer. The type must match the direction specified in the MSB of bmRequestType.\n\nThe `data` parameter of the callback is always undefined for OUT transfers, or will be passed a Buffer for IN transfers.\n\n### .interface(interface)\nReturn the interface with the specified interface number.\n\n### .interfaces\nList of Interface objects for the interfaces of the default configuration of the device.\n\n### .timeout\nTimeout in milliseconds to use for controlTransfer and endpoint transfers.\n\n### .reset(callback(error))\nPerforms a reset of the device. Callback is called when complete.\n\n\nInterface\n---------\n\n### .endpoint(address)\nReturn the InEndpoint or OutEndpoint with the specified address.\n\n### .endpoints\nList of endpoints on this interface: InEndpoint and OutEndpoint objects.\n\n### .interface\nInteger interface number.\n\n### .altSetting\nInteger alternate setting number.\n\n### .setAltSetting(altSetting, callback(error))\nSets the alternate setting. It updates the `interface.endpoints` array to reflect the endpoints found in the alternate setting.\n\n### .claim()\nClaims the interface. This method must be called before using any endpoints of this interface.\n\n### .release(callback(error))\nReleases the interface and resets the alternate setting. Calls callback when complete.\n\n### .isKernelDriverActive()\nReturns `false` if a kernel driver is not active; `true` if active.\n\n### .detachKernelDriver()\nDetaches the kernel driver from the interface.\n\n### .attachKernelDriver()\nRe-attaches the kernel driver for the interface.\n\n### .descriptor\nObject with fields from the interface descriptor -- see libusb documentation or USB spec.\n\n  - bLength\n  - bDescriptorType\n  - bInterfaceNumber\n  - bAlternateSetting\n  - bNumEndpoints\n  - bInterfaceClass\n  - bInterfaceSubClass\n  - bInterfaceProtocol\n  - iInterface\n\nEndpoint\n--------\n\nCommon base for InEndpoint and OutEndpoint, see below.\n\n### .direction\nEndpoint direction: `usb.LIBUSB_ENDPOINT_IN` or `usb.LIBUSB_ENDPOINT_OUT`.\n\n### .transferType\nEndpoint type: `usb.LIBUSB_TRANSFER_TYPE_BULK`, `usb.LIBUSB_TRANSFER_TYPE_INTERRUPT`, or `usb.LIBUSB_TRANSFER_TYPE_ISOCHRONOUS`.\n\n###  .descriptor\nObject with fields from the endpoint descriptor -- see libusb documentation or USB spec.\n\n  - bLength\n  - bDescriptorType\n  - bEndpointAddress\n  - bmAttributes\n  - wMaxPacketSize\n  - bInterval\n  - bRefresh\n  - bSynchAddress\n\nInEndpoint\n----------\n\nEndpoints in the IN direction (device->PC) have this type.\n\n### .transfer(length, callback(error, data))\nPerform a transfer to read data from the endpoint.\n\nIf length is greater than maxPacketSize, libusb will automatically split the transfer in multiple packets, and you will receive one callback with all data once all packets are complete.\n\n`this` in the callback is the InEndpoint object.\n\n### .startStream(nTransfers=3, transferSize=maxPacketSize)\nStart a streaming transfer from the endpoint.\n\nThe library will keep `nTransfers`\ntransfers of size `transferSize` pending in the kernel at all times to ensure\ncontinuous data flow. This is handled by the libusb event thread, so it continues even\nif the Node v8 thread is busy. The `data` and `error` events are emitted as transfers complete.\n\n### .stopStream()\nStop the streaming transfer.\n\nFurther data may still be received. The `end` event is emitted once all transfers have completed or canceled.\n\n### Event: data(data : Buffer)\nEmitted with data received by the stream\n\n### Event: error(error)\nEmitted when the stream encounters an error.\n\n### Event: end\nEmitted when the stream has been canceled\n\nOutEndpoint\n-----------\n\nEndpoints in the OUT direction (PC->device) have this type.\n\n### .transfer(data, callback(error))\nPerform a transfer to write `data` to the endpoint.\n\nIf length is greater than maxPacketSize, libusb will automatically split the transfer in multiple packets, and you will receive one callback once all packets are complete.\n\n`this` in the callback is the OutEndpoint object.\n\n### .startStream(nTransfers=3, transferSize=maxPacketSize)\nStart a streaming transfer to the endpoint.\n\nThe library will help you maintain `nTransfers` transfers pending in the kernel to ensure continuous data flow.\nThe `drain` event is emitted when another transfer is necessary. Your `drain` handler should use the .write() method\nto start another transfer.\n\n### .write(data)\nWrite `data` to the endpoint with the stream. `data` should be a buffer of length `transferSize` as passed to startStream.\n\nDelegates to .transfer(), but differs in that it updates the stream state tracking the number of requests in flight.\n\n### .stopStream()\nStop the streaming transfer.\n\nNo further `drain` events will be emitted. When all transfers have been completed, the OutEndpoint emits the `end` event.\n\n### Event: drain\nEmitted when the stream requests more data. Use the .write() method to start another transfer.\n\n### Event: error(error)\nEmitted when the stream encounters an error.\n\n### Event: end\nEmitted when the stream has been stopped and all pending requests have been completed.\n\n\nDevelopment and testing\n=======================\n\nTo build from git:\n\n\tgit clone https://github.com/nonolith/node-usb.git\n\tcd node-usb\n\tnpm install\n\nTo execute the unit tests, [CoffeeScript](http://coffeescript.org) is required. Run\n\n\tnpm test\n\nSome tests require an attached USB device -- firmware to be released soon.\n\nLimitations\n===========\n\nDoes not support:\n\n  - Configurations other than the default one\n  - Isochronous transfers\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/nonolith/node-usb/issues"
  },
  "_id": "usb@0.2.3",
  "dist": {
    "shasum": "63320ce09e4bcd3974512c3086b9ab12d4527d96"
  },
  "_from": "usb@",
  "_resolved": "https://registry.npmjs.org/usb/-/usb-0.2.3.tgz"
}
